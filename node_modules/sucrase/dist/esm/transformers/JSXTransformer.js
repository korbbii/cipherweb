


import XHTMLEntities from "../parser/plugins/jsx/xhtml";
import {JSXRole} from "../parser/tokenizer";
import {TokenType as tt} from "../parser/tokenizer/types";
import {charCodes} from "../parser/util/charcodes";

import getJSXPragmaInfo, {} from "../util/getJSXPragmaInfo";

import Transformer from "./Transformer";

export default class JSXTransformer extends Transformer {
  
  
  

  // State for calculating the line number of each JSX tag in development.
  __init() {this.lastLineNumber = 1}
  __init2() {this.lastIndex = 0}

  // In development, variable name holding the name of the current file.
  __init3() {this.filenameVarName = null}
  // Mapping of claimed names for imports in the automatic transform, e,g.
  // {jsx: "_jsx"}. This determines which imports to generate in the prefix.
  __init4() {this.esmAutomaticImportNameResolutions = {}}
  // When automatically adding imports in CJS mode, we store the variable name
  // holding the imported CJS module so we can require it in the prefix.
  __init5() {this.cjsAutomaticModuleNameResolutions = {}}

  constructor(
     rootTransformer,
     tokens,
     importProcessor,
     nameManager,
     options,
  ) {
    super();this.rootTransformer = rootTransformer;this.tokens = tokens;this.importProcessor = importProcessor;this.nameManager = nameManager;this.options = options;JSXTransformer.prototype.__init.call(this);JSXTransformer.prototype.__init2.call(this);JSXTransformer.prototype.__init3.call(this);JSXTransformer.prototype.__init4.call(this);JSXTransformer.prototype.__init5.call(this);;
    this.jsxPragmaInfo = getJSXPragmaInfo(options);
    this.isAutomaticRuntime = options.jsxRuntime === "automatic";
    this.jsxImportSource = options.jsxImportSource || "react";
  }

  process() {
    if (this.tokens.matches1(tt.jsxTagStart)) {
      this.processJSXTag();
      return true;
    }
    return false;
  }

  getPrefixCode() {
    let prefix = "";
    if (this.filenameVarName) {
      prefix += `const ${this.filenameVarName} = ${JSON.stringify(this.options.filePath || "")};`;
    }
    if (this.isAutomaticRuntime) {
      if (this.importProcessor) {
        // CJS mode: emit require statements for all modules that were referenced.
        for (const [path, resolvedName] of Object.entries(this.cjsAutomaticModuleNameResolutions)) {
          prefix += `var ${resolvedName} = require("${path}");`;
        }
      } else {
        // ESM mode: consolidate and emit import statements for referenced names.
        const {createElement: createElementResolution, ...otherResolutions} =
          this.esmAutomaticImportNameResolutions;
        if (createElementResolution) {
          prefix += `import {createElement as ${createElementResolution}} from "${this.jsxImportSource}";`;
        }
        const importSpecifiers = Object.entries(otherResolutions)
          .map(([name, resolvedName]) => `${name} as ${resolvedName}`)
          .join(", ");
        if (importSpecifiers) {
          const importPath =
            this.jsxImportSource + (this.options.production ? "/jsx-runtime" : "/jsx-dev-runtime");
          prefix += `import {${importSpecifiers}} from "${importPath}";`;
        }
      }
    }
    return prefix;
  }

  processJSXTag() {
    const {jsxRole, start} = this.tokens.currentToken();
    // Calculate line number information at the very start (if in development
    // mode) so that the information is guaranteed to be queried in token order.
    const elementLocationCode = this.options.production ? null : this.getElementLocationCode(start);
    if (this.isAutomaticRuntime && jsxRole !== JSXRole.KeyAfterPropSpread) {
      this.transformTagToJSXFunc(elementLocationCode, jsxRole);
    } else {
      this.transformTagToCreateElement(elementLocationCode);
    }
  }

  getElementLocationCode(firstTokenStart) {
    const lineNumber = this.getLineNumberForIndex(firstTokenStart);
    return `lineNumber: ${lineNumber}`;
  }

  /**
   * Get the line number for this source position. This is calculated lazily and
   * must be called in increasing order by index.
   */
  getLineNumberForIndex(index) {
    const code = this.tokens.code;
    while (this.lastIndex < index && this.lastIndex < code.length) {
      if (code[this.lastIndex] === "\n") {
        this.lastLineNumber++;
      }
      this.lastIndex++;
    }
    return this.lastLineNumber;
  }

  /**
   * Convert the current JSX element to a call to jsx, jsxs, or jsxDEV. This is
   * the primary transformation for the automatic transform.
   *
   * Example:
   * <div a={1} key={2}>Hello{x}</div>
   * becomes
   * jsxs('div', {a: 1, children: ["Hello", x]}, 2)
   */
  transformTagToJSXFunc(elementLocationCode, jsxRole) {
    const isStatic = jsxRole === JSXRole.StaticChildren;
    // First tag is always jsxTagStart.
    this.tokens.replaceToken(this.getJSXFuncInvocationCode(isStatic));

    let keyCode = null;
    if (this.tokens.matches1(tt.jsxTagEnd)) {
      // Fragment syntax.
      this.tokens.replaceToken(`${this.getFragmentCode()}, {`);
      this.processAutomaticChildrenAndEndProps(jsxRole);
    } else {
      // Normal open tag or self-closing tag.
      this.processTagIntro();
      this.tokens.appendCode(", {");
      keyCode = this.processProps(true);

      if (this.tokens.matches2(tt.slash, tt.jsxTagEnd)) {
        // Self-closing tag, no children to add, so close the props.
        this.tokens.appendCode("}");
      } else if (this.tokens.matches1(tt.jsxTagEnd)) {
        // Tag with children.
        this.tokens.removeToken();
        this.processAutomaticChildrenAndEndProps(jsxRole);
      } else {
        throw new Error("Expected either /> or > at the end of the tag.");
      }
      // If a key was present, move it to its own arg. Note that moving code
      // like this will cause line numbers to get out of sync within the JSX
      // element if the key expression has a newline in it. This is unfortunate,
      // but hopefully should be rare.
      if (keyCode) {
        this.tokens.appendCode(`, ${keyCode}`);
      }
    }
    if (!this.options.production) {
      // If the key wasn't already added, add it now so we can correctly set
      // positional args for jsxDEV.
      if (keyCode === null) {
        this.tokens.appendCode(", void 0");
      }
      this.tokens.appendCode(`, ${isStatic}, ${this.getDevSource(elementLocationCode)}, this`);
    }
    // We're at the close-tag or the end of a self-closing tag, so remove
    // everything else and close the function call.
    this.tokens.removeInitialToken();
    while (!this.tokens.matches1(tt.jsxTagEnd)) {
      this.tokens.removeToken();
    }
    this.tokens.replaceToken(")");
  }

  /**
   * Convert the current JSX element to a createElement call. In the classic
   * runtime, this is the only case. In the automatic runtime, this is called
   * as a fallback in some situations.
   *
   * Example:
   * <div a={1} key={2}>Hello{x}</div>
   * becomes
   * React.createElement('div', {a: 1, key: 2}, "Hello", x)
   */
  transformTagToCreateElement(elementLocationCode) {
    // First tag is always jsxTagStart.
    this.tokens.replaceToken(this.getCreateElementInvocationCode());

    if (this.tokens.matches1(tt.jsxTagEnd)) {
      // Fragment syntax.
      this.tokens.replaceToken(`${this.getFragmentCode()}, null`);
      this.processChildren(true);
    } else {
      // Normal open tag or self-closing tag.
      this.processTagIntro();
      this.processPropsObjectWithDevInfo(elementLocationCode);

      if (this.tokens.matches2(tt.slash, tt.jsxTagEnd)) {
        // Self-closing tag; no children to process.
      } else if (this.tokens.matches1(tt.jsxTagEnd)) {
        // Tag with children and a close-tag; process the children as args.
        this.tokens.removeToken();
        this.processChildren(true);
      } else {
        throw new Error("Expected either /> or > at the end of the tag.");
      }
    }
    // We're at the close-tag or the end of a self-closing tag, so remove
    // everything else and close the function call.
    this.tokens.removeInitialToken();
    while (!this.tokens.matches1(tt.jsxTagEnd)) {
      this.tokens.removeToken();
    }
    this.tokens.replaceToken(")");
  }

  /**
   * Get the code for the relevant function for this context: jsx, jsxs,
   * or jsxDEV. The following open-paren is included as well.
   *
   * These functions are only used for the automatic runtime, so they are always
   * auto-imported, but the auto-import will be either CJS or ESM based on the
   * target module format.
   */
  getJSXFuncInvocationCode(isStatic) {
    if (this.options.production) {
      if (isStatic) {
        return this.claimAutoImportedFuncInvocation("jsxs", "/jsx-runtime");
      } else {
        return this.claimAutoImportedFuncInvocation("jsx", "/jsx-runtime");
      }
    } else {
      return this.claimAutoImportedFuncInvocation("jsxDEV", "/jsx-dev-runtime");
    }
  }

  /**
   * Return the code to use for the createElement function, e.g.
   * `React.createElement`, including the following open-paren.
   *
   * This is the main function to use for the classic runtime. For the
   * automatic runtime, this function is used as a fallback function to
   * preserve behavior when there is a prop spread followed by an explicit
   * key. In that automatic runtime case, the function should be automatically
   * imported.
   */
  getCreateElementInvocationCode() {
    if (this.isAutomaticRuntime) {
      return this.claimAutoImportedFuncInvocation("createElement", "");
    } else {
      const {jsxPragmaInfo} = this;
      const resolvedPragmaBaseName = this.importProcessor
        ? this.importProcessor.getIdentifierReplacement(jsxPragmaInfo.base) || jsxPragmaInfo.base
        : jsxPragmaInfo.base;
      return `${resolvedPragmaBaseName}${jsxPragmaInfo.suffix}(`;
    }
  }

  /**
   * Return the code to use as the component when compiling a shorthand
   * fragment, e.g. `React.Fragment`.
   *
   * This may be called from either the classic or automatic runtime, and
   * the value should be auto-imported for the automatic runtime.
   */
  getFragmentCode() {
    if (this.isAutomaticRuntime) {
      return this.claimAutoImportedName(
        "Fragment",
        this.options.production ? "/jsx-runtime" : "/jsx-dev-runtime",
      );
    } else {
      const {jsxPragmaInfo} = this;
      const resolvedFragmentPragmaBaseName = this.importProcessor
        ? this.importProcessor.getIdentifierReplacement(jsxPragmaInfo.fragmentBase) ||
          jsxPragmaInfo.fragmentBase
        : jsxPragmaInfo.fragmentBase;
      return resolvedFragmentPragmaBaseName + jsxPragmaInfo.fragmentSuffix;
    }
  }

  /**
   * Return code that invokes the given function.
   *
   * When the imports transform is enabled, use the CJSImportTransformer
   * strategy of using `.call(void 0, ...` to avoid passing a `this` value in a
   * situation that would otherwise look like a method call.
   */
  claimAutoImportedFuncInvocation(funcName, importPathSuffix) {
    const funcCode = this.claimAutoImportedName(funcName, importPathSuffix);
    if (this.importProcessor) {
      return `${funcCode}.call(void 0, `;
    } else {
      return `${funcCode}(`;
    }
  }

  claimAutoImportedName(funcName, importPathSuffix) {
    if (this.importProcessor) {
      // CJS mode: claim a name for the module and mark it for import.
      const path = this.jsxImportSource + importPathSuffix;
      if (!this.cjsAutomaticModuleNameResolutions[path]) {
        this.cjsAutomaticModuleNameResolutions[path] =
          this.importProcessor.getFreeIdentifierForPath(path);
      }
      return `${this.cjsAutomaticModuleNameResolutions[path]}.${funcName}`;
    } else {
      // ESM mode: claim a name for this function and add it to the names that
      // should be auto-imported when the prefix is generated.
      if (!this.esmAutomaticImportNameResolutions[funcName]) {
        this.esmAutomaticImportNameResolutions[funcName] = this.nameManager.claimFreeName(
          `_${funcName}`,
        );
      }
      return this.esmAutomaticImportNameResolutions[funcName];
    }
  }

  /**
   * Process the first part of a tag, before any props.
   */
  processTagIntro() {
    // Walk forward until we see one of these patterns:
    // jsx171K1f1]2t22222223X3b33334+4;4g4r4444
55/5Z5d5z555555677.7<7Z777778
9(9I9f9999::::::;3;K;{;;;;;;; <<<3<?<Q<]<o<<<<<
=5=O=k=x===>>>>?"?:?O?a???? P    0;000061J1[1l11112R2`2p222222222=3V3x333333334 4O4a4s444444
556636G6a6o66666607:7L7Z778"8A8K8[8s8888889p9999:):;:K:k:u::::;?;T;; <1<f<<===>? `    00193354<4445]55555"6666667-7M7777a8m8899_999992:9:E:P:g:y::::::;;;&;-;B;h;;;;;<<G<_<w<<<<<
= ======>>i>>>4?B?T?? p    f0001131W1a1p1133c4~4444444555.5X5a5m5z5555555555666%7,7Z7d7777777888/888888888888899!9C9T9x99999999:e::::;6;B;;;1<=<<=x?~?????       )1[1h111112*2f222222233!33334 4Y4444<5E5P5i55555X666-7j777777F8o889M9999;;8<B<Y>>"??  h   y0v1!2{333e4445'5d5j555 66<7>8M8n8889U9`9b:::::;n;"<.<I<m<<<=="=B====\>-?  X   0001141R1\1m11111\345Q6]6p666L7o777=8M8g8y888889$;;j>>G?    4   2U2`3V6D7l7e8w829<B=O===>??????    P   e12H4f4x44445G5o55@6s667Y77%89!9:3;;;<<<=.=;===>?    P    0C0051M1k112_2222333J5~556V7778889`9999:;n;>>    T   "0K0{0000Q25566"6r6(788889999(:U:;+<9<v<<=D=>>>>?`??  X   K0]0001S112s22D3f3}33!4f4k45555V6{66v7779888;B<<=>>>S??     l   50001225^6m667&717M77788889C9k99999::.::::;*;:;F;V;b;z;;;7<s<<2=Q=T>e>    x   R00'1I111R2444444#5)566I6P6;;;;<<<*<7<F<d<p<<===>>6>?>j>z>>>>>??6?C?U?]?m?v????       0020C0000)1H2R2d22223=3N3334O555555566,6=6G67#7?78
888)8-8<8D8I8Y8c8g88888I9U9v999999999::,:=:W:g:n:t;};;;;<?<<==6=b==== >P>>5????   0    0040J0h112222R3333444d666g777878J888899:1::::: ;;%;{;;;<<<<2=b======>2>:>J>T>v>>>>>
?E?K?i?{?????   @    0001%1J1[111122x22H3V3344"4z44445@55566E66666C77s888(9S9}999,:B:i::;S;o;;;;<g<<<9=N==N>v>>?+?G?d?t??? P    /0Q0s00000222	3r33334 44444/5l5*6y667777V8\8b8h8n8t8z88888888999%9+91979e9k9q9w9}999998:::::;	;;8;K;l;;;<=c==l>>>?(?S?b???? ` 8   V000=11'2y2	3_45b55:66q7 8D88799:;;< p h   Q0a0001U11
33	44445N555#6[66667S777738n888s999:C:~::;<4<<=g===I>c>  `   m2w2222222222333.383H3R3h3r33333444445
55666+7S7:M;?????  T   %111j33,48444444"5/5E5555899P:l:s:::B=[=i===>Y>>>v????     0N0_00s1111D2~222K3c33333	4Y4s444555606,7S777O8|8883999:;;;;Q<w<<<<<"=9=z=====	>??     H0V0000181F1w11122\3334+4444]5h5556S6k667?7j77778'8=8S88:9x999999::#:4:e:|::::D;;<q<<<<<<<6=L=m===>R>>>>#???       A0Z001\1s112Q22223A3s33404h4444)5L5Z5555-6E6i6|673888899^9p94:H:z::::;+;O;^;;;;;H<U<<<#=h====8>>>>>>?L??       22666687^7j7z77788'88888888$9D9L9T9\9h999999999 ::: :D:L:T:\:d:l:t:|:::::::::::;;$;,;L;T;`;;;;;;;;;; <<,<8<X<d<<<<<<<<==$=D=L=T=\=h========= >>>4><>D>P>p>|>>>>>>>>> ?$?,?4?<?D?L?T?\?d?l?x?????????    T  00$0D0L0T0\0h000000000 1141<1D1L1T1\1d1l1x11111111112222$2,242<2D2L2T2\2d2l2t2|2222222223$3,343<3D3L3T3`333333333333334(40484D4d4l4t4|444444445555(5H5T5t5555555555555 6 6(60686@6H6P6`666666666666666667777$7,747<7D7L7T7`77777777778(8H8T8t8|8888888889$9,949<9D9L9T9\9d9p99999999:$:0:P:X:`:h:p:|:::::::;(;0;8;@;H;T;t;;;;;;;;;; < <,<L<X<x<<<<<<<<<< ==,=4=<=H=h=p=|==========>$>0>P>X>`>h>p>x>>>>>>>???8?@?H?P?X?`?h?t???????    ,   0 0(040T0\0h0000000001$1,181X1`1l111111122<2H2h2t222222222223$303P3\3|33333333334(404<4\4d4l4t444444444445(50585@5L5l5x5555555 6666$6D6L6X6x666666677787@7L7l7x77777778(8H8h88888888889 9$949X9d9l99999999999::,:0:@:d:p:x:::::::::::;; ;(;0;D;L;T;\;p;x;;;;;;;;;;; <<<$<8<@<H<P<d<l<t<|<<<<<<<<<<<<<<<<<<< ====== =$=,=0=4=<=@=L=l=t======== >>>$>,>4><>D>T>`>h>>>>>>>>? ?@?H?T?t?|????????      0 0,0L0X0x00000001(101<1\1d1p111111111112$2,282X2`2l222222222223$303P3X3`3h3t3333333 4 4(444T4`44444445505<5\5h5555555556$606P6\6|6666666677<7H7h7t77777778$8D8P8p8|888888 9 9,9L9T9`999999999: :@:L:l:t:::::::;$;,;8;X;d;;;;;;;;; < <,<L<T<\<d<p<<<<<<== =(=\=l=x=======>$>,>4>@>`>l>>>>>>>??<?D?P?p?x????????       0080@0L0T000000001(1H1T1t1111111 2222<2D2L2T2\2h22222222222333343@3`3h3t333333333334$4,484@4t44444444445505<5\5d5l5x55555555666$6D6L6X6x66666667777$707P7\7|7   d    00(0D0h000 111 2234@55`66077p88(::;x;;H<< =P=p=====>4>X>>>X????? 0    (0t000 @    2                                                                                                                                                                                          '    0'	*H'0'10	`He 0\
+7N0L0
+70	  010	`He  y-D:吃qW|YwA1G.s[P2腑003  MN(x    M0	*H 0~10	UUS10U
Washington10URedmond10U
Microsoft Corporation1(0&UMicrosoft Code Signing PCA 20110230316184328Z240314184328Z0t10	UUS10U
Washington10URedmond10U
Microsoft Corporation10UMicrosoft Corporation0"0	*H  0
 (
VqAM78衷+)xZCe桴明F91宓~xQ3
2xb0_闳v,?oc}l请蹈`2u技o3Wa喝KC^2,ioATT饩l|$峋#}1/mYZF穹MO.c1B`Tr储wk^j埋:{A'U逭wO蓖舀1fh妫	QRfe蹯iN}R7jMC溅Py>Jd虏]1pm 0~0U%0
+7L+0U!NTr49b鬲!/0TUM0KI0G1-0+U$Microsoft Ireland Operations Limited10U230012+5005170U#0HndP77"mㄊu0TUM0K0IGEChttp://www.microsoft.com/pkiops/crl/MicCodSigPCA2011_2011-07-08.crl0a+U0S0Q+0Ehttp://www.microsoft.com/pkiops/certs/MicCodSigPCA2011_2011-07-08.crt0U0 0	*H  #O女毯昧nMF^鳊杯oCAY'V2ZS/ec8LCaIJo;Z!嵇[v钶OoLf\~t(<:腑'M娱v'2L:-P6KF"f咎i桨8#DX^KZM-h'lF|j#非tqwY衬.!候%8*apRV2V渌0暝/'ORZ;sCkCeXó#CX!r#X~!suao_,D珧镥akミ,N└闽
>%'(1\河gJ#;s,Ps柏Jn$Vy*Q+'@_荷<殃)'Z宽)wW畿鳏Ow'j*SM梅Y0跹Rcd0Ljo孤76T[奈JO阼误亚}蔸vYNsD!rsa际)６Y{!B廴G^;Z@>@=
1\痒s&AQ >呐0z0b
a     0	*H 010	UUS10U
Washington10URedmond10U
Microsoft Corporation1200U)Microsoft Root Certificate Authority 20110110708205909Z260708210909Z0~10	UUS10U
Washington10URedmond10U
Microsoft Corporation1(0&UMicrosoft Code Signing PCA 20110"0	*H  0
 瘊r.nM4候X!B*kZP8I7k8叭91Byd~`$lIh^疫S
,茂侃+z	Y`fv2R&/绔P铣D]啬.uh笏m:\F亨8dnd5xc-@戕\yI)w=稃+ZMV(zr:I^仨C{{>]O颉/Y;-3X欧>2映=辈8~,NV!5%9ndS#唆_鹦R祭!t%_(短'(8%9J6|#Зfaj(I_%]!K>R牡W?$鹧z[/#p]QFw厨 峒_劾辰UK9#ID|E淞rzr$呖F棚WMI0Й哽[莅f饬{碇KI)(Η}gbx_/W\w((耥m(,@7O玲D	L旁C/tnx X,]`>O3诎okens.code.slice(token.start, token.end);
    const replacementCode = formatJSXTextReplacement(valueCode);
    const literalCode = formatJSXTextLiteral(valueCode);
    if (literalCode === '""') {
      this.tokens.replaceToken(replacementCode);
      return false;
    } else {
      this.tokens.replaceToken(`${needsComma ? ", " : ""}${literalCode}${replacementCode}`);
      return true;
    }
  }

  getDevSource(elementLocationCode) {
    return `{fileName: ${this.getFilenameVarName()}, ${elementLocationCode}}`;
  }

  getFilenameVarName() {
    if (!this.filenameVarName) {
      this.filenameVarName = this.nameManager.claimFreeName("_jsxFileName");
    }
    return this.filenameVarName;
  }
}

/**
 * Spec for identifiers: https://tc39.github.io/ecma262/#prod-IdentifierStart.
 *
 * Really only treat anything starting with a-z as tag names.  `_`, `$`, `茅`
 * should be treated as component names
 */
export function startsWithLowerCase(s) {
  const firstChar = s.charCodeAt(0);
  return firstChar >= charCodes.lowercaseA && firstChar <= charCodes.lowercaseZ;
}

/**
 * Turn the given jsxText string into a JS string literal. Leading and trailing
 * whitespace on lines is removed, except immediately after the open-tag and
 * before the close-tag. Empty lines are completely removed, and spaces are
 * added between lines after that.
 *
 * We use JSON.stringify to introduce escape characters as necessary, and trim
 * the start and end of each line and remove blank lines.
 */
function formatJSXTextLiteral(text) {
  let result = "";
  let whitespace = "";

  let isInInitialLineWhitespace = false;
  let seenNonWhitespace = false;
  for (let i = 0; i < text.length; i++) {
    const c = text[i];
    if (c === " " || c === "\t" || c === "\r") {
      if (!isInInitialLineWhitespace) {
        whitespace += c;
      }
    } else if (c === "\n") {
      whitespace = "";
      isInInitialLineWhitespace = true;
    } else {
      if (seenNonWhitespace && isInInitialLineWhitespace) {
        result += " ";
      }
      result += whitespace;
      whitespace = "";
      if (c === "&") {
        const {entity, newI} = processEntity(text, i + 1);
        i = newI - 1;
        result += entity;
      } else {
        result += c;
      }
      seenNonWhitespace = true;
      isInInitialLineWhitespace = false;
    }
  }
  if (!isInInitialLineWhitespace) {
    result += whitespace;
  }
  return JSON.stringify(result);
}

/**
 * Produce the code that should be printed after the JSX text string literal,
 * with most content removed, but all newlines preserved and all spacing at the
 * end preserved.
 */
function formatJSXTextReplacement(text) {
  let numNewlines = 0;
  let numSpaces = 0;
  for (const c of text) {
    if (c === "\n") {
      numNewlines++;
      numSpaces = 0;
    } else if (c === " ") {
      numSpaces++;
    }
  }
  return "\n".repeat(numNewlines) + " ".repeat(numSpaces);
}

/**
 * Format a string in the value position of a JSX prop.
 *
 * Use the same implementation as convertAttribute from
 * babel-helper-builder-react-jsx.
 */
function formatJSXStringValueLiteral(text) {
  let result = "";
  for (let i = 0; i < text.length; i++) {
    const c = text[i];
    if (c === "\n") {
      if (/\s/.test(text[i + 1])) {
        result += " ";
        while (i < text.length && /\s/.test(text[i + 1])) {
          i++;
        }
      } else {
        result += "\n";
      }
    } else if (c === "&") {
      const {entity, newI} = processEntity(text, i + 1);
      result += entity;
      i = newI - 1;
    } else {
      result += c;
    }
  }
  return JSON.stringify(result);
}

/**
 * Starting at a &, see if there's an HTML entity (specified by name, decimal
 * char code, or hex char code) and return it if so.
 *
 * Modified from jsxReadString in babel-parser.
 */
function processEntity(text, indexAfterAmpersand) {
  let str = "";
  let count = 0;
  let entity;
  let i = indexAfterAmpersand;

  if (text[i] === "#") {
    let radix = 10;
    i++;
    let numStart;
    if (text[i] === "x") {
      radix = 16;
      i++;
      numStart = i;
      while (i < text.length && isHexDigit(text.charCodeAt(i))) {
        i++;
      }
    } else {
      numStart = i;
      while (i < text.length && isDecimalDigit(text.charCodeAt(i))) {
        i++;
      }
    }
    if (text[i] === ";") {
      const numStr = text.slice(numStart, i);
      if (numStr) {
        i++;
        entity = String.fromCodePoint(parseInt(numStr, radix));
      }
    }
  } else {
    while (i < text.length && count++ < 10) {
      const ch = text[i];
      i++;
      if (ch === ";") {
        entity = XHTMLEntities.get(str);
        break;
      }
      str += ch;
    }
  }

  if (!entity) {
    return {entity: "&", newI: indexAfterAmpersand};
  }
  return {entity, newI: i};
}

function isDecimalDigit(code) {
  return code >= charCodes.digit0 && code <= charCodes.digit9;
}

function isHexDigit(code) {
  return (
    (code >= charCodes.digit0 && code <= charCodes.digit9) ||
    (code >= charCodes.lowercaseA && code <= charCodes.lowercaseF) ||
    (code >= charCodes.uppercaseA && code <= charCodes.uppercaseF)
  );
}
